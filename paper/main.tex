\documentclass[conference]{IEEEtran}

\usepackage{algorithm,algorithmic}  %% typset algorithms
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
%%\usepackage{newpxtext}  %% for _e.g._ macro.
\usepackage{textgreek}
\usepackage{xspace}

% use these if you also want π to work in math mode
\usepackage{newunicodechar}
\newunicodechar{Π}{\ifmmode\Pi\else\textPi\fi}

% use quotes as smart-quotes. https://tex.stackexchange.com/a/52354
\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}

\renewcommand{\paragraph}[1]{\vspace*{2pt}\noindent\textbf{#1}}

\newcommand{\system}{\textsc{SystemName}\xspace}

\title{Title Goes Here}

\author{First1 Last1}
%%\authornote{with author1 note}        %% and a great more deleted...


\begin{document}

\newtheorem{definition}{Definition}

\ExplSyntaxOn    %% https://tex.stackexchange.com/a/639374/244649
\newcommand { \eg }
{ \textit{e.g.}
  \peek_meaning_ignore_spaces:NTF .
    { \skip_horizontal:n { -.3ex } \use_none:n }
    { \peek_meaning_ignore_spaces:NF , { \skip_horizontal:n { -.3ex } } }
}
\newcommand { \ie }
{ \textit{i.e.}
  \peek_meaning_ignore_spaces:NTF .
    { \skip_horizontal:n { -.3ex } \use_none:n }
    { \peek_meaning_ignore_spaces:NF , { \skip_horizontal:n { -.3ex } } }
}
\ExplSyntaxOff

\newcommand{\termOfArt}[1]{\textbf{#1}}


\maketitle
\thispagestyle{plain}
\pagestyle{plain}

\begin{abstract}
  Formal methods for guaranteeing that a protocol satisfies a cryptographic security definition have advanced substantially,
  but such methods are still labor intensive and the need remains for an automated tool that can positively identify an insecure protocol.
  We show that the philosophy of property-based-testing, \textit{"run it a bunch of times and see if it breaks"},
  is at least somewhat feasible in a cryptographic setting.
  We specifically target Secure Multi-Party Computation, because formal methods targeting this security definition for bit-model implementations
  are particularly difficult.
  Using results from the literature for Probabilistic Programming Languages and statistical inference, we devise a test that can
  detect various flaws in a bit-level implementation of an MPC protocol.
  The test is grey-box; it requires only transcripts of randomness consumed by the protocol and of the inputs, outputs, and messages.
  It successfully detects several different mistakes and biases introduced into two different implementations of the classic GMW protocol.
  Applied to thousands of randomly generated protocols, it identifies nearly all of them as insecure.
  We also include an analysis of the parameters of the test, and discussion of what makes detection of MPC (in)security difficult.
\end{abstract}

\section{Introduction}

\dots  %% TODO: intorduction per se?

\subsection{Motivation}

As in all kinds of engineering; in cryptography it is critical to know that the thing you are building actually does what you intend.
In cryptography however, the intended behavior is often expressed as a negation,
\eg secret information should \textit{never} be derivable from such'n'such surface of the system.
Observing of the system's behavior provides limited evidence that the system is actually secure in the intended ways.
Formal proofs of security are a popular and well-suited solution to this problem, however:

\begin{itemize}
    \item As consumers, we are concerned that a great deal of cyber-security software has been and is being produced without formal verification.
    \item As engineers, we would like to not waste time attempting to prove the security of systems which, unbeknownst to us, are not actually secure.
    \item As product managers, we would like to have sanity checks
          that complicated software systems actually have the security properties their constituent source-code claims to be proven to have.
\end{itemize}

In this work we particularly focus on Secure Multi-Party Computation (MPC),
a cryptographic primitive with wide-ranging applications but frustrating performance limitations.
Substantial work has going into improving the performance of MPC systems [TODO: citation].
Additionally, in some cases performance can be improved by using a bespoke protocol instead of a general-purpose MPC system [do we have any evidence of this?].
We accelerate this work by providing a tool, comparable to a property-based test,
for conveniently spot-checking the security of an MPC implementation.

\subsection{Contributions}

In this work we present and evaluate a statistical test of the security of MPC protocols.
First we show how MPC security relates to inference and equivalence of probabilistic distributions,
and then we demonstrate that existing tests of distributional equivalence can, with minor modification, be used to refute MPC security.
Our tool is adaptable to the wide range of cryptographic security properties that can be defined in terms of distributional equivalence,
and our tool is applicable to any software system that
A) can be run 10k-1M times without great inconvenience, and
B) allows certain intermediate values (of which consumed randomness is the least convenient) to be captured for analysis.

\section{Background}

\subsection{MPC security}

Secure Multi-Party Computation (MPC or SMPC, depending on the text)
is a cryptographic process that allows some group of participating parties or machines
to compute a function that depends on all of their private inputs,
without any of them learning anything except the final result.
Implementations that work on arbitrary functions (representable as circuit computations in some field)
have existed since 1982 [TODO: citation], % https://ieeexplore.ieee.org/document/4568207
but their use by the public is limited by their performance.
Some performance limitations are fundamental to the problem
(roughly, every branch of the computation must be executed so that the control-flow does not itself leak information),
but techniques have been found to improve performance somewhat.

The traditional expression of MPC assumes a pre-determined function F, "the functionality",
mapping the tuple of all participants' input vectors to the respective tuple of output vectors
(or to distributions of outputs, if F is non-deterministic).
In an \termOfArt{ideal world}, a trusted third party (the \termOfArt{ideal functionality}) would accept input messages
from all other parties, compute F, and then send the parties their respective outputs.
A \termOfArt{real world} protocol Π is said to \textit{correctly} implement F if, for all possible inputs,
Π results in all parties getting the same outputs as they would have in the ideal world.
Defining the \textit{security} of Π requires a clear threat model, and requires defining the participants' "views".

\termOfArt{Passive Security} supposes a computationally-bounded adversary
that can see everything happening inside a fixed subset of the participating machines.
This adversary cannot cause the parties to deviate from the protocol Π in any way;
we are interested in whether it can learn anything (beyond the outputs of the "corrupted" machines)
by observing the execution of Π.
As an example, this notion of security might be of interest if Alice trusted Bob to participate
in a distributed computation with her, but did not trust him to properly store or destroy the log-files
generated.
The \termOfArt{ideal world view}, $\mathsf{Ideal}_P(F,\vec{x})$, of a party P is what it sees when running F in the ideal world:
just its inputs $\vec{x}_P$ and its outputs.
The \termOfArt{real world view}, $\mathsf{Real}_P(Π, \vec{x})$, of a party P is everything it sees while executing its part of Π in the real world:
its inputs, outputs, all messages it receives, and all the bits of random tape it uses.
Both these concepts extend to naturally to lists of parties.

\begin{definition}[Passive MPC Security]
    A protocol Π,
    involving participating parties P,
    that correctly implements functionality F,
    is secure against a passive adversary controlling C$\subset$P iff
    there exists a poly-time-computable function $\mathtt{SIM}$ s.t.
    $$\begin{aligned}
        \mathsf{Real}_C(Π, \vec{x}) &\cong \mathtt{SIM}(\mathsf{Ideal}_C(F,\vec{x}))
    \end{aligned}$$
    where $\cong$ denotes distributional equivelence or indistinguishabilty.
\end{definition}

This definition represents security by a transitive argument:
Since the adversary in the ideal world can compute all the data the real-world adversary starts with,
anything the real-world adversary can compute the ideal-world adversary can also compute!

In practice, security is usually quantified over all possible corruptions $C$
where $\lvert C \rvert \leq \frac{\lvert P \rvert}{r}$ for some $r$, but this is not fundamental and we only consider a single $C$ at a time.

Definition 1 is tight, in the sense that attempting to relax it invariable either
allows a "secure" protocol to do something bad, or requires introducing restrictions
on the kinds of functionality to which the definition may be applied.
(Of course the idea that a secure protocol \textit{can't} do anything bad implies an assumption that computing
the functionality is a good thing. [move to footnote])
That said, some simplification is possible for our purposes:
Since the (passive) corrupted parties are assumed to follow Π faithfully, we are fine to limit ourselves to
\termOfArt{choreographic} protocols in which all messages sent are expected and all messages expected are received.
In this context, and because the only source of non-determinism is the parties' random tapes
(which are captured in the real-world views),
we can safely ignore any messages sent \textit{within} C.
Then we can collapse all the corrupted parties C into a single party C,
and similarly all the other parties into a single party H (for "honest")
(we don't always do this).
Finally, in this work we assume that protocols implement their functionalities \textit{correctly},
and usually leave the corresponding F implicit.
In other words, we define F to be whatever mapping results from the execution of Π.
This present work describes a system for property-based testing of MPC \textit{security};
a corresponding test of \textit{correctness} is trivial for any pre-defined F.

\termOfArt{Active Security} (sometimes "malicious security")
supposes a computationally bounded adversary that can cause corrupted machines to take arbitrary actions,
breaking the choreography,
forging messages (to such extent as that's actually possible),
lying about computation results,
and/or playing along with the protocol for any period of time.
In contrast to passive adversaries, which are weaker than the threat models most real programmers worry about,
an active adversary subsumes any threat model (including adaptive corruption, depending how it's framed).
The corresponding security definition is a bit more involved, and we omit it for brevity.
Since we're not directly testing for active security in this work,
all else that needs to be said about it is that
any protocol which is not \termOfArt{passive secure} is automatically not \termOfArt{active secure}.

Certain edge cases are helpful to consider, as they really do map out the edges of the problem of testing from MPC security.
In the first case, Π itself may be vacuous.
A \termOfArt{vacuous protocol}, one in which no information (random bits don't count), is communicated is automatically secure,
although of course it can only correctly implement trivial functionalities.
On the other hand, if the ideal-world adversary can efficiently deduce a unique possible honest input upon observing the corrupt output,
then the protocol is \termOfArt{vacuously secure}: \textit{any} correct implementation of that functionality is secure regardless of what's communicated.
These extremes mark the ends of a spectrum; most protocols are somewhere in the middle,
where learning the output focuses the corrupt party's distribution-estimate of the honest secrets but still leaves some uncertainty.
On the other hand, this spectrum doesn't capture the assumptions about the adversary's computational limits;
if inverting the functionality F is NP-hard, then the protocol is \textit{not} vacuously secure, even if F is a bijection.

TODO: maybe say we invented these; give examples. Readers will assume these are existing terms if we don't say otherwise.

While MPC can be expressed as a kind of non-interference property, this is only somewhat useful.
The non-interference can only be meant within the space of possible program traces \textit{posterior to the output}.
Similarly, trying to avoid such subtleties in the non-interference property by providing a correctly constrained \texttt{reveal} operator
isn't promising because constraints on \texttt{reveal} would need to recapitulate the original question of security
and examine the entire rest of the protocol as context.

TODO: maybe state it explicitly with the conditioning? Then we can say that no system can capture that property.

\subsection{Inference in PPLs}

Efficient inversion of programs and fragments of programs turns out to be so important for determining if a protocol satisfies MPC security.
Since MPC protocols are probabilistic, what we really need is efficient posterior inference of program inputs in a
\termOfArt{probabilistic programming language} (PPL).

A PPL is a language that provides stochastic non-deterministic behavior as a language primitive
and provides meta-theory or auxiliary tooling to reason about the resulting distributions of program behavior.
In particular, PPLs commonly have semantics defined in terms of transformations on distributions,
and are designed to ensure that the resulting distributions are amenable to specified techniques for efficient
inference and sampling. Since even representing a fully-general multivariate distribution takes exponential space with respect to the number of variables,
PPLs typically restrict the programs and/or distributions they can handle.

For application to the subject of MPC protocols, a PPL would need to handle the two different kinds of uncertainty facing a hypothetical adversary:
1) Random values generated (by any party) at runtime have known distributions
(\eg the python expression \texttt{secrets.SystemRandom().random()}
will sample at runtime from the best floating-point approximation the machine can provide
of the uniform distribution on $\mathbb{R}_{(0,1]}$).
2) The secret inputs of the honest parties are not stochastic at all, but the adversary can be asked to provide a distribution over
possible secrets representing their prior belief so that the secret inputs can also be modeled as random variables.

Hypothetically, supposing a protocol in a PPL providing a multivariate distribution over an appropriate subset of all runtime values,
if it were possible to efficiently infer and sample from the real-world views
(or other variables sufficient to deterministically compute a view)
\textit{posterior to} the corrupt outputs (and corrupt inputs),
then that would suffice as a simulator
\textit{if and only if} the inferred distribution were independent of the adversary's choice of prior distribution for the honest secrets.
So a direct test of MPC security (or a useful over-approximation) could be built from
A) a language meta-theory guarantee that such posterior inference and sampling would be efficient,
B) a test or guarantee of independence between the posterior view distribution and the exponentially-many parameters
of the prior distribution of honest secrets[TODO: footnote], and
C) the ability to quantify (A) and (B) over all possible corrupt secrets or public inputs, presumably by handling them symbolically.
Such a system is not necessarily impossible, but we have so far failed to build it.

TODO: Is efficient inference really necessary? The conditional independence test might be sufficient? I think we don't want to imply that inference is sufficient, because lots of work has done that

\subsection{Property-based testing}

In industry the normal way to see if a program satisfies some desired property is to run it and see what it does.
Sometimes this is done with a select handful of inputs or configurations,
but non-deterministic programs are better evaluated with \termOfArt{property-based testing},
in which the program is run with many arbitrary (but not necessarily random) configurations.
Property-based testing is a popular paradigm for testing code in industry;
the classic Haskell framework QuickCheck [citation] % https://www.cse.chalmers.se/~rjmh/QuickCheck/
is still in use and has been ported to various other languages.

At face value, property-based testing doesn't generally extend to hyper-properties,
which can only be assessed by comparing multiple program traces.
In practice sometimes one can express a hyper-property as a property of multiple of duplicate programs,
but the sensitivity of the test quickly decays and the logistics of setting up the test quickly grow.
Furthermore, when the property to be tested is over distributions of traces,
the various used by good property-based testing frameworks to efficiently find interesting cases are not appropriate.

TODO: maybe cite the Kifer work on property-based testing for DP (also a hyperproperty) and call out that our setting is (maybe) fundamentally high-dimensional so it's super tricky.

\section{Related Work}

[ computer proofs of MPC paper; (double-check malicions case...)
  l-obliv
  wysteria et al
  probabilistic separation logic]
\subsection{Verification of MPC}

[Computer-aided proofs for multiparty computation with active security](https://arxiv.org/pdf/1806.07197.pdf)

\subsection{Languages built inside of MPC implementations}

\subsection{PPLs for Inference}

dice

\subsection{PPL proof assistants}

lilac

\subsection{Probabilistic tests of distributional equality}

[decision trees paper]()

\section{The tool in theory}

... Position the equivalence in the definition of MPC security...

To actually test a protocol, one uses two identical machine learning (ML) tools to predict the honest secrets based on the corrupt views.
One of the two models has access to the "real world" views, and the only has access to the "ideal world" views.
In principal, \textit{any} ML system is ok to use; the choice is partly an engineering question
and partly a judgment call about what kinds of systems will be best able to discern patterns in the views of the subject protocol.
Generating the data for these tests requires running the protocol many times.
The process is enumerated in Algorithm 1.

Note that the data must be understood as vectors/matricies/tensors of bits. [is this actually important? are there exceptions/precondidtions?]

\begin{algorithm}  %% https://tex.stackexchange.com/a/219820/244649
  \caption{Does it need a name?}
  \begin{algorithmic}[1]
  \STATE Set a chosen number of iterations `iters`,
         number of rows of data on which to train each model `trainN`,
         and number of rows of data on which to test each model `testN`.
  \STATE Choose $\alpha$, your probability of randomly flagging a secure protocol as insecure.
  \FOR {`i <- [1..iters]`, calculate scores for the real and ideal models:}
    \STATE Run the protocol `trainN` times, collecting the corrupt views and honest secrets.
    \STATE Train the first ML model on the collected data.
           The real-world views are the input features, and the honest secrets are the labels. [I think this is generic ML terminology?]
    \STATE Train the second ML model the same way, but occlude (omit or overwrite) view data to only reveal the ideal-world view.
    \STATE Run the protocol `testN` more times, again collecting the relevant data.
    \STATE The score for each model is the $L^1$ distance between the testing labels and the respective model outputs
           (\ie the number of bits wrong when run on the `testN` rows of test data).
  \ENDFOR
  \STATE Using the `iters` samples of "real-world" and "ideal-world" scores,
         calculate the $p$-value for the hypothesis that the distribution of real-world scores is better on average than the ideal-world distribution.
  \IF {$p \leq \alpha$} \RETURN `INSECURE` \ELSE \RETURN `SECURE` \ENDIF
  \end{algorithmic}
\end{algorithm}

\subsection{Issue: false positives}

What our tool actually invalidates is that the views are uniformly random within the slice compatible with the obseved inputs and outputs. 


\section{The tool in practice}

[How weedy do we want to get here?]


\subsection{A Choreography Language}

Our python script for actually performing the test consumes a stream of fixed-length bit vectors.
(In practice, this is a CSV. Annotation of which columns are available in the real and ideal worlds is provided in the header.)
[Does our tool strictly need the vectors to be fixed width? Could someone do this kind of test on a system with branching control flow?]
To facilitate analysis of the tool, we implemented a choreographic programming language, CHO,
with surrounding tooling to support large batches of parallel evaluations of a single program and piping of the generated data.
The design of CHO is driven by the contextual assumptions of MPC security.
[Do we want a BNF? Semantics?]
In addition to bit-level computations and transmission of single bits between arbitrary parties,
each party has its own read-only tape for secret inputs and random bits
(CHO is also a probabilistic language),
and its own tape for output bits.
CHO supports macros, but they are extremely limited.
Finally, CHO supports 1-of-N oblivious transfer as a primitive operation.
This allows us to test (correct and incorrect) implementations of the classic GMW protocol.

\subsection{Random generation of programs}

The goal of this work is a tool that can detect mistakes in MPC protocols.
Such a tools is only useful if there if new protocols and implementations are being written.
Therefore, while it is critical to demonstrate that our tool can detect errors manually edite into known-secure protocols,
we \textit{also} need to show that the tool can detect a lack of security in entirely novel and maximally diverse protocols.
We attempt to show this by randomly generating hundreds [can we say thousands?] of protocols and testing them with different test parameters.

The probability that a randomly generated protocol will be MPC secure is not completely negligible.
As an easy example, if no communicated values ever depend on secret inputs, then the protocol meets the definition of security!
(Never mind that such a protocol is useless; \textit{none} of the protocols we generated are \textit{useful}.)
That said, for reasonable generator settings we find that \textit{very few} generated protocols
continue to appear secure as we increase the power of the test.

[Probably a lot of the details of the generator go in the appendix?]

\subsection{Performance analysis}


\section{Case Study Protocols}
\label{sec:case-study-protocols}

For our evaluation, we implemented six MPC protocols from the literature in \system, and evaluated \system's scalability and ability to find implementation bugs in these protocols. The six protocols are listed in Table~\ref{tbl:protocols}. One is a simple addition protocol, three are basic building blocks often used to build more complex protocols, and two are protocols designed to securely evaluate circuits. All six protocols are designed for two parties, with the addition of a third ``dealer'' party to produce correlated randomness in several of the protocols.

\begin{table}
\centering
  \begin{tabular}{|l | l|l|}
    \hline
    \textbf{Protocol} & \textbf{Purpose} & \textbf{Ref.} \\
    \hline
    $n$-bit Addition & Custom & TODO \\
    Oblivious Transfer & Building block & TODO \\
%    OT Extension & Building block & TODO \\
    Beaver Triple Generation & Building block & TODO \\
    GMW & Circuit evaluation & TODO \\
    MPC w/ Beaver Triples & Circuit evaluation & TODO \\
    \hline
  \end{tabular}
  \caption{Secure protocols used in our evaluation.}
  \label{tbl:protocols}
\end{table}

\paragraph{$n$-bit Addition.}
The simplest protocol in our evaluation is a basic summation protocol, which adds up the inputs from the two participating parties. To accomplish this task, the protocol essentially simulates a hardware adder circuit---for each bit in the binary representation of the two input numbers, the protocol performs bitwise operations to compute the sum and carry bit. To ensure security, the input values are \emph{secret shared} using additive secret sharing; to secret share a bit, a party selects a random bit to represent one share, and computes the other share by XORing the random bit with the secret bit. In \system, $P_1$ can secret share the bit $x$ with $P_2$ as follows:
%
\begin{verbatim}
  s1 = FLIP @P1
  s2 = x + s1
  SEND s1 TO P2
\end{verbatim}
%
$P_1$ can safely send one share to $P_2$, as long as $P_1$ keeps the other share for themselves---neither share alone reveals anything about the secret bit. To add (i.e. XOR) two secret-shared bits, each party can simply add its shares for the two bits to obtain one share of the result. To multiply (i.e. AND) two secret-shared bits, the parties must use oblivious transfer (described next).

Our $n$-bit addition protocol generates a \system source file for a given bitwidth. In our evaluation, we test several different bitwidths to examine the effect of the size of each party's view on the scalability and bug-finding capability of \system.

\paragraph{Oblivious Transfer.}
Oblivious transfer~\cite{todo} (OT) is a 2-party protocol that allows one party ($R$, the \emph{receiver}) to select one out of several secret inputs provided by the other party ($S$, the \emph{sender}). In 1-out-of-2 OT, $S$ provides 2 secret inputs $x_0$ and $x_1$ and $R$ provides a secret \emph{selection bit} $b$. If $b=0$, $R$ receives $x_0$; if $b=1$, $R$ receives $x_1$. $R$ does not learn anything about the not-selected secret, and $S$ does not learn which secret $R$ selected. This idea can be extended to 1-out-of-$n$ OT by extending the selection bit $b$ to a $\log_2(n)$-bit string.
%
Oblivious transfer is a building block for many other protocols.

% \paragraph{Oblivious Transfer Extension.}
% Protocols like GMW (described later) require the use of OT for each AND gate---for large circuits, this means thousands or millions of OTs. \emph{OT extension}~\cite{todo} is an approach for expanding $k$ ``base'' OTs into $m \gg k$ OTs. OT extension can significantly improve the performance of protocols that use many OTs.

\paragraph{Beaver Triple Generation.}
A \emph{Beaver triple}~\cite{todo} (or \emph{multiplication triple}) is a set of secret shares of numbers $a$, $b$, and $c$ such that $a \cdot b = c$. To use a Beaver triple, $P_1$ must have one share of each of $a$, $b$, and $c$, and $P_2$ must have the other share. Since the values are secret shared, they appear random to each party---but the correlation between the three numbers can be used to perform efficient multiplication between secret-shared numbers (described later). One Beaver triple must be consumed for each multiplication, but they can be generated in a separate offline phase. Beaver triples can be generated by a trusted ``dealer'' party, or by using oblivious transfer. We implement both versions in \system.

\paragraph{GMW (Goldreich-Micali-Widgerson).}
The GMW protocol is an MPC protocol for evaluating circuits. Each party holds additive secret shares of each wire's value, and evaluates addition gates by adding the shares they hold. The parties evaluate multiplication gates by using 1-out-of-4 oblivious transfer: the first party generates a random bit for its share of the output, and acts as the sender in OT; the second party acts as the receiver in OT and receives its share of the output. We implemented a compiler to generate \system programs that evaluate  Bristol fashion circuits using GMW, and evaluated it on circuits implementing integer addition and integer inequalities.

\paragraph{MPC with Beaver Triples.}
Another MPC protocol for evaluating circuits also uses additive shares to hold wire values, but uses Beaver triples to evaluate multiplication gates (instead of OT). Given shares of a Beaver triple, the parties perform two multiplication-by-constant and broadcast operations, and derive one share each of the product. Our implementation of this approach employees a third-party ``dealer'' who generates the triples; a pre-processing (offline) phase can also be used to generate the triples. We evaluate \system on this protocol using the same circuits as in our GMW experiments.


% \paragraph{Circuits.}
% To evaluate the circuit-based protocols, we used five binary circuits that are publicly available in the ``Bristol-fashion'' format~\cite{todo}. We chose commonly-used circuits with a range of sizes to test \system's scalability. Table~\ref{tbl:circuits} lists the circuits used in our evaluation, along with the number of gates in each circuit.

% \begin{table}
% \centering
%   \begin{tabular}{|l |l|l|}
%     \hline
%     \textbf{Circuit} & \textbf{AND Gates} & \textbf{Total Gates} \\
%     \hline
%     64-bit adder & 63 & 376 \\
%     64-bit multiplier & 4,033 & 13,675 \\
%     AES-128 & 6,400 & 36,663 \\
%     SHA-256 & 22,573 & 135,073 \\
%     Floating-point division & 82,269 & 184,007 \\
%     \hline
%   \end{tabular}
%   \caption{Circuits used in our evaluation.}
%   \label{tbl:circuits}
% \end{table}

\section{Evaluation}

Our empirical evaluation demonstrates \system's ability to detect bugs in secure protocols. Our experiments are designed to answer two research questions:
%
\begin{itemize}
\item \textbf{RQ1:} Is \system capable of detecting insecurity in complex, multi-round protocols?
\item \textbf{RQ2:} Is \system capable of detecting insecurity in real-world protocols?
\item \textbf{RQ3:} Is \system scalable to realistic protocols in reasonable time?
\end{itemize}
%
To answer RQ1, we generate \emph{random protocols} of varying sizes, and evaluate \system's ability to show they are insecure. The details appear in Section~\ref{sec:experiment-1:-random}. To answer RQ2, we evaluate \system on the case study protocols described in Section~\ref{sec:case-study-protocols}. The details appear in Section~\ref{sec:experiment-2:-real}. In both cases, \system is able to detect insecurity in the target protocols in under a minute.

\subsection{Experiment 1: Random Protocols}
\label{sec:experiment-1:-random}

\paragraph{Experiment setup.}
In our first experiment, we generate random protocols and evaluate \system's ability to detect insecurity in these protocols. We randomly generate protocols according to the grammar of XXX. We bias the generated protocols in favor of generating and using randomness in each round of the protocol, in addition to the secret inputs. Random protocols of non-trivial length are extremely likely to be insecure.
%
We generate XXXX programs of size XXXX and evaluate \system's ability to detect insecurity.

\paragraph{Results.}
\emph{results description goes here}


\subsection{Experiment 2: Real-world Protocols}
\label{sec:experiment-2:-real}

\paragraph{Experiment setup.}
In our second experiment, we evaluate \system's ability to detect insecurity in the real-world protocols described in Section~\ref{sec:case-study-protocols}. We run \system on the unmodified protocol in order to establish that the protocol is secure. Then, we mutate the protocol in several ways to introduce insecurity, and test \system's ability to detect it. Specifically, our mutations are:
%
\begin{itemize}
\item \textbf{Accidental secret}: accidentally sends a secret held by the honest party  to the corrupt party.
\item \textbf{Accidental gate}: accidentally sends an honest party's result from the evaluation of a multiplication gate to the corrupt party.
\item \textbf{Biased sharing}: uses biased randomness to construct secret shares of honest party inputs.
\item \textbf{Biased AND}: uses biased randomness as part of the evaluation of multiplication gates.
\end{itemize}
%
The severity of each mutation can be tuned by adjusting the bias in the related randomness. In the case of ``accidental secret'' and ``accidental gate,'' this affects the probability of accidentally revealing a value; in the others, it directly adjust the bias in the randomness.

\paragraph{Results.} \emph{results description goes here}

\subsection{Discussion}




\section{Future Work}


\section{Conclusions}

\end{document}
