\documentclass[conference]{IEEEtran}

\usepackage{algorithm,algorithmic}  %% typset algorithms
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
%%\usepackage{newpxtext}  %% for _e.g._ macro.
\usepackage{textgreek}
\usepackage{xspace}

% use these if you also want π to work in math mode
\usepackage{newunicodechar}
\newunicodechar{Π}{\ifmmode\Pi\else\textPi\fi}

\renewcommand{\paragraph}[1]{\vspace*{2pt}\noindent\textbf{#1}}

\newcommand{\system}{\textsc{SystemName}\xspace}

\title{Title Goes Here}

\author{First1 Last1}
%%\authornote{with author1 note}        %% and a great more deleted...


\begin{document}

\newtheorem{definition}{Definition}

\ExplSyntaxOn    %% https://tex.stackexchange.com/a/639374/244649
\newcommand { \eg }
{ \textit{e.g.}
  \peek_meaning_ignore_spaces:NTF .
    { \skip_horizontal:n { -.3ex } \use_none:n }
    { \peek_meaning_ignore_spaces:NF , { \skip_horizontal:n { -.3ex } } }
}
\newcommand { \ie }
{ \textit{i.e.}
  \peek_meaning_ignore_spaces:NTF .
    { \skip_horizontal:n { -.3ex } \use_none:n }
    { \peek_meaning_ignore_spaces:NF , { \skip_horizontal:n { -.3ex } } }
}
\ExplSyntaxOff

\newcommand{\termOfArt}[1]{\textbf{#1}}


\maketitle

\begin{abstract}
  Abstract goes here.
\end{abstract}

\section{Introduction}

\dots  %% TODO: intorduction per se?

\subsection{Motivation}

As in all kinds of engineering; in cryptography it is critical to know that the thing you are building actually does what you intend.
In cryptography however, the intended behavior is often expressed as a negation,
\eg secret information should \textit{never} be derivable from such'n'such surface of the system.
Observing of the system's behavior provides limited evidence that the system is actually secure in the intended ways.
Formal proofs of security are a popular and well-suited solution to this problem, however:

\begin{itemize}
    \item As consumers, we are concerned that a great deal of cyber-security software has been and is being produced without formal verification.
    \item As engineers, we would like to not waste time attempting to prove the security of systems which, unbeknownst to us, are not actually secure.
    \item As product managers, we would like to have sanity checks
          that complicated software systems actually have the security properties their constituent source-code claims to be proven to have.
\end{itemize}

In the work we particularly focus on Secure Multi-Party Computation (MPC),
a cryptographic primitive with wide-ranging applications but frustrating performance limitations.
Substantial work has going into improving the performance of MPC systems [citation].
Additionally, in some cases performance can be improved by using a bespoke protocol instead of a general-purpose MPC system [do we have any evidence of this?].
We accelerate this work by providing a tool, comparable to a property-based test,
for conveniently spot-checking the security of an MPC implementation.

\subsection{Contributions}

In this work we present and evaluate a statistical test of the security of MPC protocols.
First we show how MPC security relates to inference and equivalence of probabilistic distributions,
and then we demonstrate that existing tests of distributional equivalence can, with minor modification, be used to refute MPC security.
Our tool is adaptable to the wide range of cryptographic security properties that can be defined in terms of distributional equivalence,
and our tool is applicable to any software system that
A) can be run 10k-1M times without great inconvenience, and
B) allows certain intermediate values (of which consumed randomness is the least convenient) to be captured for analysis.

\section{Background}

\subsection{MPC security}

Secure Multi-Party Computation (MPC or SMPC, depending on the text)
is a cryptographic process that allows some group of participating parties or machines
to compute a function that depends on all of their private inputs,
without any of them learning anything except the final result.
Implementations that work on arbitrary functions (representable as circuit computations in some field)
have existed since [...],
but their use by the public is limited by their performance.
Some performance limitations are fundamental to the problem
(roughly, every branch of the computation must be executed so that the control-flow does not itself leak information),
but techniques have been found to improve performance somewhat.

The traditional expression of MPC assumes a pre-determined function F, "the functionality",
mapping the tuple of all participants' input vectors to the respective tuple of output vectors
(or to distributions of outputs, if F is non-deterministic).
In an \termOfArt{ideal world}, a trusted third party (the \termOfArt{ideal functionality}) would accept input messages
from all other parties, compute F, and then send the parties their respective outputs.
A \termOfArt{real world} protocol Π is said to correctly implement F if, for all possible inputs,
Π results in all parties getting the same outputs as they would have in the ideal world.
Defining the security of Π requires a clear threat model, and requires defining the participants' "views".

\termOfArt{Passive Security} supposes a computationally-bounded adversary
that can see everything happening inside a fixed subset of the participating machines.
This adversary cannot cause the parties to deviate from the protocol Π in any way;
we are interested in whether it can learn anything beyond the outputs of the "corrupted" machines
by observing the execution of Π.
As an example, this notion of security might be of interest if Alice trusted Bob to participate
in a distributed computation with her, but did not trust him to properly store or destroy the log-files
generated.
The \termOfArt{ideal world view} of a party is what it sees in the ideal world: just its inputs and outputs.
The \termOfArt{real world view} of a party is everything it sees in the real world while executing its part of Π:
its inputs, outputs, all messages it receives, and all the bits of random tape it uses.

\begin{definition}[Passive MPC Security]
A protocol Π,
involving participating parties P,
that correctly implements functionality F,
is secure against a passive adversary controlling C$\subset$P iff
there exists a poly-time-computable function SIM s.t.
....
\end{definition}

This definition represents security by a transitive argument:
Since the adversary in the ideal world can compute all the data the real-world adversary starts with,
anything the real-world adversary can compute the ideal-world adversary can also compute!

In practice, security is usually quantified over all possible corruptions C
where |C|$\leq$|P|/x for some x, but this is not fundamental and we only consider a single C at a time.

Definition 1 is tight, in the sense that attempting to relax it invariable either
allows a "secure" protocol to do something bad, or requires introducing restrictions
on the kinds of functionality to which the definition may be applied.
(Of course the idea that a secure protocol \textit{can't} do anything bad implies an assumption that computing
the functionality is a good thing. [move to footnote])
That said, some simplification is possible for our purposes:
Since the corrupted parties are assumed to follow Π faithfully, we are fine to limit ourselves to
choreographic protocols in which all messages sent are expected and all messages expected are received.
In this context, and because the only source of non-determinism is the parties' random tapes
(which are captured in the real-world views),
we can safely ignore any messages sent \textit{within} C.
Then we can collapse all the corrupted parties C into a single party C,
and similarly all the other parties into a single party H (for "honest").
Finally, in this work we assume that protocols implement their functionalities \textit{correctly},
and usually leave the corresponding F implicit.
In other words, we define F to be whatever mapping results from the execution of Π.
This present work describes a system for property-based testing of MPC \textit{security};
a corresponding test of \textit{correctness} is trivial for any pre-defined F.

\termOfArt{Active Security} (sometimes "malicious security")
supposes a computationally bounded adversary that can cause corrupted machines to take arbitrary actions,
breaking the choreography,
forging messages (to such extent as that's actually possible),
lying about computation results,
and/or playing along with the protocol for any period of time.
In contrast to passive adversaries, which are weaker than the threat models most real programmers worry about,
an active adversary subsumes any threat model (including adaptive corruption, depending how it's framed).
The corresponding security definition is a bit more involved, and we omit it for brevity.
Since we're not directly testing for active security in this work,
all else that needs to be said about it is that
any protocol which is not \termOfArt{passive secure} is automatically not \termOfArt{active secure}.

[Other aspects we may wish to cover:
 vacuous protocols,
 vacuous security,
 infertabilty of functionality,
 comparison to control flow properties,
 review of other work,
 review of stuff we tried that didn't work...
 ]

[ computer proofs of MPC paper; (double-check malicions case...)
  l-obliv
  wysteria et al
  probabilistic separation logic]

\subsection{Inference in PPLs}

\subsection{Property-based testing}


\section{Related Work}

\subsection{Verification of MPC}

[Computer-aided proofs for multiparty computation with active security](https://arxiv.org/pdf/1806.07197.pdf)

\subsection{Languages built inside of MPC implementations}

\subsection{PPLs for Inference}

dice

\subsection{PPL proof assistants}

lilac

\subsection{Probabilistic tests of distributional equality}

[decision trees paper]()

\section{The tool in theory}

... Position the equivalence in the definition of MPC security...

To actually test a protocol, one uses two identical machine learning (ML) tools to predict the honest secrets based on the corrupt views.
One of the two models has access to the "real world" views, and the only has access to the "ideal world" views.
In principal, \textit{any} ML system is ok to use; the choice is partly an engineering question
and partly a judgment call about what kinds of systems will be best able to discern patterns in the views of the subject protocol.
Generating the data for these tests requires running the protocol many times.
The process is enumerated in Algorithm 1.

Note that the data must be understood as vectors/matricies/tensors of bits. [is this actually important? are there exceptions/precondidtions?]

\begin{algorithm}  %% https://tex.stackexchange.com/a/219820/244649
  \caption{Does it need a name?}
  \begin{algorithmic}[1]
  \STATE Set a chosen number of iterations `iters`,
         number of rows of data on which to train each model `trainN`,
         and number of rows of data on which to test each model `testN`.
  \STATE Choose $\alpha$, your probability of randomly flagging a secure protocol as insecure.
  \FOR {`i <- [1..iters]`, calculate scores for the real and ideal models:}
    \STATE Run the protocol `trainN` times, collecting the corrupt views and honest secrets.
    \STATE Train the first ML model on the collected data.
           The real-world views are the input features, and the honest secrets are the labels. [I think this is generic ML terminology?]
    \STATE Train the second ML model the same way, but occlude (omit or overwrite) view data to only reveal the ideal-world view.
    \STATE Run the protocol `testN` more times, again collecting the relevant data.
    \STATE The score for each model is the $L^1$ distance between the testing labels and the respective model outputs
           (\ie the number of bits wrong when run on the `testN` rows of test data).
  \ENDFOR
  \STATE Using the `iters` samples of "real-world" and "ideal-world" scores,
         calculate the $p$-value for the hypothesis that the distribution of real-world scores is better on average than the ideal-world distribution.
  \IF {$p \leq \alpha$} \RETURN `INSECURE` \ELSE \RETURN `SECURE` \ENDIF
  \end{algorithmic}
\end{algorithm}

\subsection{Issue: false positives}

What our tool actually invalidates is that the views are uniformly random within the slice compatible with the obseved inputs and outputs. 


\section{The tool in practice}

[How weedy do we want to get here?]


\subsection{A Choreography Language}

Our python script for actually performing the test consumes a stream of fixed-length bit vectors.
(In practice, this is a CSV. Annotation of which columns are available in the real and ideal worlds is provided in the header.)
[Does our tool strictly need the vectors to be fixed width? Could someone do this kind of test on a system with branching control flow?]
To facilitate analysis of the tool, we implemented a choreographic programming language, CHO,
with surrounding tooling to support large batches of parallel evaluations of a single program and piping of the generated data.
The design of CHO is driven by the contextual assumptions of MPC security.
[Do we want a BNF? Semantics?]
In addition to bit-level computations and transmission of single bits between arbitrary parties,
each party has its own read-only tape for secret inputs and random bits
(CHO is also a probabilistic language),
and its own tape for output bits.
CHO supports macros, but they are extremely limited.
Finally, CHO supports 1-of-N oblivious transfer as a primitive operation.
This allows us to test (correct and incorrect) implementations of the classic GMW protocol.

\subsection{Random generation of programs}

The goal of this work is a tool that can detect mistakes in MPC protocols.
Such a tools is only useful if there if new protocols and implementations are being written.
Therefore, while it is critical to demonstrate that our tool can detect errors manually edite into known-secure protocols,
we \textit{also} need to show that the tool can detect a lack of security in entirely novel and maximally diverse protocols.
We attempt to show this by randomly generating hundreds [can we say thousands?] of protocols and testing them with different test parameters.

The probability that a randomly generated protocol will be MPC secure is not completely negligible.
As an easy example, if no communicated values ever depend on secret inputs, then the protocol meets the definition of security!
(Never mind that such a protocol is useless; \textit{none} of the protocols we generated are \textit{useful}.)
That said, for reasonable generator settings we find that \textit{very few} generated protocols
continue to appear secure as we increase the power of the test.

[Probably a lot of the details of the generator go in the appendix?]

\subsection{Performance analysis}


\section{Case Study Protocols}

For our evaluation, we implemented six MPC protocols from the literature in \system, and evaluated \system's scalability and ability to find implementation bugs in these protocols. The six protocols are listed in Table~\ref{tbl:protocols}. One is a simple addition protocol, three are basic building blocks often used to build more complex protocols, and two are protocols designed to securely evaluate circuits. All six protocols are designed for two parties, with the addition of a third ``dealer'' party to produce correlated randomness in several of the protocols.

\begin{table}
\centering
  \begin{tabular}{|l | l|l|}
    \hline
    \textbf{Protocol} & \textbf{Purpose} & \textbf{Ref.} \\
    \hline
    $n$-bit Addition & Custom & TODO \\
    Oblivious Transfer & Building block & TODO \\
    OT Extension & Building block & TODO \\
    Beaver Triple Generation & Building block & TODO \\
    GMW & Circuit evaluation & TODO \\
    MPC w/ Beaver Triples & Circuit evaluation & TODO \\
    \hline
  \end{tabular}
  \caption{Secure protocols used in our evaluation.}
  \label{tbl:protocols}
\end{table}

\paragraph{$n$-bit Addition.}
The simplest protocol in our evaluation is a basic summation protocol, which adds up the inputs from the two participating parties. To accomplish this task, the protocol essentially simulates a hardware adder circuit---for each bit in the binary representation of the two input numbers, the protocol performs bitwise operations to compute the sum and carry bit. To ensure security, the input values are \emph{secret shared} using additive secret sharing; to secret share a bit, a party selects a random bit to represent one share, and computes the other share by XORing the random bit with the secret bit. In \system, $P_1$ can secret share the bit $x$ with $P_2$ as follows:
%
\begin{verbatim}
  s1 = FLIP @P1
  s2 = x + s1
  SEND s1 TO P2
\end{verbatim}
%
$P_1$ can safely send one share to $P_2$, as long as $P_1$ keeps the other share for themselves---neither share alone reveals anything about the secret bit. To add (i.e. XOR) two secret-shared bits, each party can simply add its shares for the two bits to obtain one share of the result. To multiply (i.e. AND) two secret-shared bits, the parties must use oblivious transfer (described next).

Our $n$-bit addition protocol generates a \system source file for a given bitwidth. In our evaluation, we test several different bitwidths to examine the effect of the size of each party's view on the scalability and bug-finding capability of \system.

\paragraph{Oblivious Transfer.}
Oblivious transfer~\cite{todo} (OT) is a 2-party protocol that allows one party ($R$, the \emph{receiver}) to select one out of several secret inputs provided by the other party ($S$, the \emph{sender}). In 1-out-of-2 OT, $S$ provides 2 secret inputs $x_0$ and $x_1$ and $R$ provides a secret \emph{selection bit} $b$. If $b=0$, $R$ receives $x_0$; if $b=1$, $R$ receives $x_1$. $R$ does not learn anything about the not-selected secret, and $S$ does not learn which secret $R$ selected. This idea can be extended to 1-out-of-$n$ OT by extending the selection bit $b$ to a $\log_2(n)$-bit string.
%
Oblivious transfer is a building block for many other protocols. For example, the GMW protocol for circuit evaluation (described later) evaluates AND gates using 1-out-of-4 OT

\paragraph{Oblivious Transfer Extension.}
Protocols like GMW (described later) require the use of OT for each AND gate---for large circuits, this means thousands or millions of OTs. \emph{OT extension}~\cite{todo} is an approach for expanding $k$ ``base'' OTs into $m \gg k$ OTs. OT extension can significantly improve the performance of protocols that use many OTs.

\paragraph{Beaver Triple Generation.}
A \emph{Beaver triple}~\cite{todo} (or \emph{multiplication triple}) is a set of secret shares of numbers $a$, $b$, and $c$ such that $a \cdot b = c$. To use a Beaver triple, $P_1$ must have one share of each of $a$, $b$, and $c$, and $P_2$ must have the other share. Since the values are secret shared, they appear random to each party---but the correlation between the three numbers can be used to perform efficient multiplication between secret-shared numbers (described later). One Beaver triple must be consumed for each multiplication, but they can be generated in a separate offline phase. Beaver triples can be generated by a trusted ``dealer'' party, or by using oblivious transfer. We implement both versions in \system.

\paragraph{GMW (Goldreich-Micali-Widgerson.}

\paragraph{MPC with Beaver Triples.}

\paragraph{Circuits.}
To evaluate the circuit-based protocols, we used five binary circuits that are publicly available in the ``Bristol-fashion'' format~\cite{todo}. We chose commonly-used circuits with a range of sizes to test \system's scalability. Table~\ref{tbl:circuits} lists the circuits used in our evaluation, along with the number of gates in each circuit.

\begin{table}
\centering
  \begin{tabular}{|l |l|l|}
    \hline
    \textbf{Circuit} & \textbf{AND Gates} & \textbf{Total Gates} \\
    \hline
    64-bit adder & 63 & 376 \\
    64-bit multiplier & 4,033 & 13,675 \\
    AES-128 & 6,400 & 36,663 \\
    SHA-256 & 22,573 & 135,073 \\
    Floating-point division & 82,269 & 184,007 \\
    \hline
  \end{tabular}
  \caption{Circuits used in our evaluation.}
  \label{tbl:circuits}
\end{table}

\section{Evaluation}

\subsection{Experiment 1: Scalability for Secure Protocols}



\subsection{Experiment 2: Bug-Finding for Insecure Protocol Mutations}

\subsection{Experiment 3: Scalability and Bug-Finding for Random Programs}


\section{Future Work}


\section{Conclusions}

\end{document}
